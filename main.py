import streamlit as st
import pandas as pd
from datetime import datetime, date, timedelta, timezone
import re
from excel_parser import (
    process_excel_data_for_calendar,
    _load_and_merge_dataframes,
    get_available_columns_for_event_name,
    check_event_name_columns,
    format_worksheet_value
)
from calendar_utils import (
    authenticate_google,
    add_event_to_calendar,
    fetch_all_events,
    update_event_if_needed,
    build_tasks_service,
    add_task_to_todo_list,
    find_and_delete_tasks_by_event_id
)
from firebase_auth import initialize_firebase, firebase_auth_form, get_firebase_user_id
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from firebase_admin import firestore

st.set_page_config(page_title="Googleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ä¸€æ‹¬ã‚¤ãƒ™ãƒ³ãƒˆç™»éŒ²ãƒ»å‰Šé™¤", layout="wide")
st.title("ğŸ“… Googleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ä¸€æ‹¬ã‚¤ãƒ™ãƒ³ãƒˆç™»éŒ²ãƒ»å‰Šé™¤")

# Firebaseã®åˆæœŸåŒ–
if not initialize_firebase():
    st.error("Firebaseã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚")
    st.stop()

# Firestoreã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®å–å¾—
db = firestore.client()

# Firebaseèªè¨¼ãƒ•ã‚©ãƒ¼ãƒ ã®è¡¨ç¤ºã¨ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã®å–å¾—
user_id = get_firebase_user_id()

if not user_id:
    firebase_auth_form()
    st.stop()

# ãƒ¦ãƒ¼ã‚¶ãƒ¼å›ºæœ‰ã®è¨­å®šã‚’Firestoreã‹ã‚‰èª­ã¿è¾¼ã‚€
def load_user_settings(user_id):
    if not user_id:
        return

    doc_ref = db.collection('user_settings').document(user_id)
    doc = doc_ref.get()

    if doc.exists:
        settings = doc.to_dict()
        if 'description_columns_selected' in settings:
            st.session_state[f'description_columns_selected_{user_id}'] = settings['description_columns_selected']
        if 'event_name_col_selected' in settings:
            st.session_state[f'event_name_col_selected_{user_id}'] = settings['event_name_col_selected']
        if 'event_name_col_selected_update' in settings:
            st.session_state[f'event_name_col_selected_update_{user_id}'] = settings['event_name_col_selected_update']
    else:
        st.session_state[f'description_columns_selected_{user_id}'] = ["å†…å®¹", "è©³ç´°"]
        st.session_state[f'event_name_col_selected_{user_id}'] = "é¸æŠã—ãªã„"
        st.session_state[f'event_name_col_selected_update_{user_id}'] = "é¸æŠã—ãªã„"

def save_user_setting(user_id, setting_key, setting_value):
    if not user_id:
        return
    doc_ref = db.collection('user_settings').document(user_id)
    try:
        doc_ref.set({setting_key: setting_value}, merge=True)
    except Exception as e:
        st.error(f"è¨­å®šã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}")

load_user_settings(user_id)

google_auth_placeholder = st.empty()

with google_auth_placeholder.container():
    st.subheader("ğŸ” Googleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼èªè¨¼")
    creds = authenticate_google()

    if not creds:
        st.warning("Googleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼èªè¨¼ã‚’å®Œäº†ã—ã¦ãã ã•ã„ã€‚")
        st.stop()
    else:
        google_auth_placeholder.empty()
        st.sidebar.success("âœ… Googleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã«èªè¨¼æ¸ˆã¿ã§ã™ï¼")

def initialize_calendar_service():
    try:
        service = build("calendar", "v3", credentials=creds)
        calendar_list = service.calendarList().list().execute()
        
        editable_calendar_options = {
            cal['summary']: cal['id']
            for cal in calendar_list['items']
            if cal.get('accessRole') != 'reader'
        }
        
        return service, editable_calendar_options
    except HttpError as e:
        st.error(f"ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ (HTTPã‚¨ãƒ©ãƒ¼): {e}")
        return None, None
    except Exception as e:
        st.error(f"ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}")
        return None, None

def initialize_tasks_service_wrapper():
    try:
        tasks_service = build_tasks_service(creds)
        if not tasks_service:
            return None, None
            
        task_lists = tasks_service.tasklists().list().execute()
        default_task_list_id = None
        
        for task_list in task_lists.get('items', []):
            if task_list.get('title') == 'My Tasks':
                default_task_list_id = task_list['id']
                break
                
        if not default_task_list_id and task_lists.get('items'):
            default_task_list_id = task_lists['items'][0]['id']
        
        return tasks_service, default_task_list_id
    except HttpError as e:
        st.warning(f"Google ToDoãƒªã‚¹ãƒˆã‚µãƒ¼ãƒ“ã‚¹ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ (HTTPã‚¨ãƒ©ãƒ¼): {e}")
        return None, None
    except Exception as e:
        st.warning(f"Google ToDoãƒªã‚¹ãƒˆã‚µãƒ¼ãƒ“ã‚¹ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}")
        return None, None

if 'calendar_service' not in st.session_state or not st.session_state['calendar_service']:
    service, editable_calendar_options = initialize_calendar_service()
    
    if not service:
        st.warning("Googleèªè¨¼ã®çŠ¶æ…‹ã‚’ç¢ºèªã™ã‚‹ã‹ã€ãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚")
        st.stop()
    
    st.session_state['calendar_service'] = service
    st.session_state['editable_calendar_options'] = editable_calendar_options
else:
    service = st.session_state['calendar_service']
    _, st.session_state['editable_calendar_options'] = initialize_calendar_service()

if 'tasks_service' not in st.session_state or not st.session_state.get('tasks_service'):
    tasks_service, default_task_list_id = initialize_tasks_service_wrapper()
    
    st.session_state['tasks_service'] = tasks_service
    st.session_state['default_task_list_id'] = default_task_list_id
    
    if not tasks_service:
        st.info("ToDoãƒªã‚¹ãƒˆæ©Ÿèƒ½ã¯åˆ©ç”¨ã§ãã¾ã›ã‚“ãŒã€ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼æ©Ÿèƒ½ã¯å¼•ãç¶šãä½¿ç”¨ã§ãã¾ã™ã€‚")
else:
    tasks_service = st.session_state['tasks_service']

tabs = st.tabs([
    "1. ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰",
    "2. ã‚¤ãƒ™ãƒ³ãƒˆã®ç™»éŒ²",
    "3. ã‚¤ãƒ™ãƒ³ãƒˆã®å‰Šé™¤",
    "4. ã‚¤ãƒ™ãƒ³ãƒˆã®æ›´æ–°"
])

if 'uploaded_files' not in st.session_state:
    st.session_state['uploaded_files'] = []
    st.session_state['description_columns_pool'] = []
    st.session_state['merged_df_for_selector'] = pd.DataFrame()

with tabs[0]:
    st.header("ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰")
    st.info("""
    â˜ä½œæ¥­æŒ‡ç¤ºæ›¸ä¸€è¦§ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã¨ç®¡ç†ç•ªå·+ç‰©ä»¶åã‚’ã‚¤ãƒ™ãƒ³ãƒˆåã¨ã—ã¦ä»»æ„ã®ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã«ç™»éŒ²ã—ã¾ã™ã€‚
    â˜ã‚¤ãƒ™ãƒ³ãƒˆã®èª¬æ˜æ¬„ã«å«ã‚ãŸã„æƒ…å ±ã¯ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ãƒªã‚¹ãƒˆã‹ã‚‰é¸æŠã—ã¦ãã ã•ã„ã€‚
    â˜ã‚¤ãƒ™ãƒ³ãƒˆã«ä½æ‰€ã‚’è¿½åŠ ã—ãŸã„å ´åˆã¯ã€ç‰©ä»¶ä¸€è¦§ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæ¥­æŒ‡ç¤ºæ›¸ä¸€è¦§ã¨ä¸€ç·’ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚
    â˜ä½œæ¥­å¤–äºˆå®šã®ä¸€è¦§ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã¨ã€ã‚¤ãƒ™ãƒ³ãƒˆåã‚’é¸æŠã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
    """)

    import os
    from pathlib import Path
    from io import BytesIO

    def get_local_excel_files():
        current_dir = Path(__file__).parent
        return [f for f in current_dir.glob("*.xlsx") if f.is_file()]

    uploaded_files = st.file_uploader("Excelãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠï¼ˆè¤‡æ•°å¯ï¼‰", type=["xlsx"], accept_multiple_files=True)

    local_excel_files = get_local_excel_files()
    selected_local_files = []
    if local_excel_files:
        st.subheader("ğŸ“ ã‚µãƒ¼ãƒãƒ¼ã«ã‚ã‚‹Excelãƒ•ã‚¡ã‚¤ãƒ«")
        local_file_names = [f.name for f in local_excel_files]
        selected_names = st.multiselect(
            "ä»¥ä¸‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡¦ç†å¯¾è±¡ã«å«ã‚ã‚‹ï¼ˆã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã¨åŒæ§˜ã«æ‰±ã‚ã‚Œã¾ã™ï¼‰",
            local_file_names
        )
        for name in selected_names:
            full_path = next((f for f in local_excel_files if f.name == name), None)
            if full_path:
                with open(full_path, "rb") as f:
                    file_bytes = f.read()
                    file_obj = BytesIO(file_bytes)
                    file_obj.name = name
                    selected_local_files.append(file_obj)

    all_files = []
    if uploaded_files:
        all_files.extend(uploaded_files)
    if selected_local_files:
        all_files.extend(selected_local_files)

    if all_files:
        st.session_state['uploaded_files'] = all_files
        try:
            st.session_state['merged_df_for_selector'] = _load_and_merge_dataframes(all_files)
            st.session_state['description_columns_pool'] = st.session_state['merged_df_for_selector'].columns.tolist()

            if st.session_state['merged_df_for_selector'].empty:
                st.warning("èª­ã¿è¾¼ã¾ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã«æœ‰åŠ¹ãªãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚")
        except (ValueError, IOError) as e:
            st.error(f"ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: {e}")
            st.session_state['uploaded_files'] = []
            st.session_state['merged_df_for_selector'] = pd.DataFrame()
            st.session_state['description_columns_pool'] = []

    if st.session_state.get('uploaded_files'):
        st.subheader("ğŸ“„ å‡¦ç†å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§")
        for f in st.session_state['uploaded_files']:
            st.write(f"- {f.name}")
        if not st.session_state['merged_df_for_selector'].empty:
            st.info(f"ğŸ“Š ãƒ‡ãƒ¼ã‚¿åˆ—æ•°: {len(st.session_state['merged_df_for_selector'].columns)}ã€è¡Œæ•°: {len(st.session_state['merged_df_for_selector'])}")

        if st.button("ğŸ—‘ï¸ ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ¸ˆã¿ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¯ãƒªã‚¢"):
            st.session_state['uploaded_files'] = []
            st.session_state['merged_df_for_selector'] = pd.DataFrame()
            st.session_state['description_columns_pool'] = []
            st.success("ã™ã¹ã¦ã®ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸã€‚")
            st.rerun()

with tabs[1]:
    st.header("ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™»éŒ²ãƒ»æ›´æ–°")
    if not st.session_state.get('uploaded_files') or st.session_state['merged_df_for_selector'].empty:
        st.info("å…ˆã«ã€Œ1. ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã€ã‚¿ãƒ–ã§Excelãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚")
    else:
        st.subheader("ğŸ“ ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š")
        all_day_event_override = st.checkbox("çµ‚æ—¥ã‚¤ãƒ™ãƒ³ãƒˆã¨ã—ã¦ç™»éŒ²", value=False)
        private_event = st.checkbox("éå…¬é–‹ã‚¤ãƒ™ãƒ³ãƒˆã¨ã—ã¦ç™»éŒ²", value=True)
        include_work_type = st.checkbox("ã‚¤ãƒ™ãƒ³ãƒˆåã®å…ˆé ­ã«ä½œæ¥­ã‚¿ã‚¤ãƒ—ã‚’è¿½åŠ ", value=False)

        current_description_cols_selection = st.session_state.get(f'description_columns_selected_{user_id}', [])
        description_columns = []
        if st.session_state.get('description_columns_pool'):
            description_columns = st.multiselect(
                "èª¬æ˜æ¬„ã«å«ã‚ã‚‹åˆ—ï¼ˆè¤‡æ•°é¸æŠå¯ï¼‰",
                st.session_state.get('description_columns_pool', []),
                default=[col for col in current_description_cols_selection if col in st.session_state.get('description_columns_pool', [])],
                key=f"description_selector_register_{user_id}",
            )
        else:
            st.info("èª¬æ˜æ¬„ã«å«ã‚ã‚‹åˆ—ã®å€™è£œãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚")
            description_columns = current_description_cols_selection

        fallback_event_name_column = None
        has_mng_data, has_name_data = check_event_name_columns(st.session_state['merged_df_for_selector'])
        selected_event_name_col = st.session_state.get(f'event_name_col_selected_{user_id}', "é¸æŠã—ãªã„")

        if not (has_mng_data and has_name_data):
            st.subheader("ã‚¤ãƒ™ãƒ³ãƒˆåã®è¨­å®š")
            available_event_name_cols = get_available_columns_for_event_name(st.session_state['merged_df_for_selector'])
            event_name_options = ["é¸æŠã—ãªã„"] + available_event_name_cols
            default_index = event_name_options.index(selected_event_name_col) if selected_event_name_col in event_name_options else 0
            
            selected_event_name_col = st.selectbox(
                "ã‚¤ãƒ™ãƒ³ãƒˆåã¨ã—ã¦ä½¿ç”¨ã™ã‚‹ä»£æ›¿åˆ—ã‚’é¸æŠã—ã¦ãã ã•ã„:",
                options=event_name_options,
                index=default_index,
                key=f"event_name_selector_register_{user_id}",
            )
            if selected_event_name_col != "é¸æŠã—ãªã„":
                fallback_event_name_column = selected_event_name_col
        else:
            st.info("ã€Œç®¡ç†ç•ªå·ã€ã¨ã€Œç‰©ä»¶åã€ãŒåˆ©ç”¨ã§ãã¾ã™ã€‚")

        if not st.session_state['editable_calendar_options']:
            st.error("ç™»éŒ²å¯èƒ½ãªã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚")
        else:
            selected_calendar_name = st.selectbox("ç™»éŒ²å…ˆã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚’é¸æŠ", list(st.session_state['editable_calendar_options'].keys()), key="reg_calendar_select")
            calendar_id = st.session_state['editable_calendar_options'][selected_calendar_name]

            st.subheader("â¡ï¸ ã‚¤ãƒ™ãƒ³ãƒˆç™»éŒ²ãƒ»æ›´æ–°å®Ÿè¡Œ")
            if st.button("Googleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã«ç™»éŒ²ãƒ»æ›´æ–°ã™ã‚‹"):
                save_user_setting(user_id, 'description_columns_selected', description_columns)
                save_user_setting(user_id, 'event_name_col_selected', selected_event_name_col)

                with st.spinner("ã‚¤ãƒ™ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’å‡¦ç†ä¸­..."):
                    try:
                        df = process_excel_data_for_calendar(
                            st.session_state['uploaded_files'],
                            description_columns,
                            all_day_event_override,
                            private_event,
                            fallback_event_name_column,
                            include_work_type=include_work_type
                        )
                    except (ValueError, IOError) as e:
                        st.error(f"Excelãƒ‡ãƒ¼ã‚¿å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼: {e}")
                        df = pd.DataFrame()

                    if df.empty:
                        st.warning("æœ‰åŠ¹ãªã‚¤ãƒ™ãƒ³ãƒˆãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚")
                    else:
                        st.info(f"{len(df)} ä»¶ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’å‡¦ç†ã—ã¾ã™ã€‚")
                        # --- ã“ã“ã‹ã‚‰å…ˆã®Googleã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ç™»éŒ²ãƒ­ã‚¸ãƒƒã‚¯ã¯å…ƒã‚³ãƒ¼ãƒ‰ã‚’ç¶­æŒ ---
                        # ï¼ˆæ—¢å­˜ã‚¤ãƒ™ãƒ³ãƒˆã®ç…§åˆãƒ»æ–°è¦ç™»éŒ²ãƒ»æ›´æ–°å‡¦ç†ï¼‰
                        # ...
